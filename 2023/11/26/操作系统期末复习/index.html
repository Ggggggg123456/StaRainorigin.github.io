
<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8" />
        <title>操作系统期末复习 | ⭐星雨起源⭐</title>
        <meta name="author" content="海画沙夢w" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/favicon.png" />
        <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>⭐星雨起源⭐</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;⭐星雨起源⭐</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div class="article">
    <div>
        <h1>操作系统期末复习</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/11/26
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="color: #00bcd4">操作系统</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" style="color: #ff7d73">期末复习</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="操作系统期末复习"><a href="#操作系统期末复习" class="headerlink" title="操作系统期末复习"></a>操作系统期末复习</h1><h2 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h2><ol>
<li><strong>设计现代OS的主要目标是什么？</strong></li>
</ol>
<p>有效性，方便性，可扩充性，开放性，</p>
<ol start="2">
<li><strong>什么是操作系统？操作系统的基本特征是什么？并简单论述</strong></li>
</ol>
<p>系统软件，管理和控制计算机硬软件资源，合理组织计算机工作流程。特征包括：并发，共享，异步，虚拟。 其中并发和共享是最基本特征。<br><strong>并发：</strong>多个事件可以同一个时间间隔内发生，可以同时处理和调度多个程序<br><strong>共享：</strong>资源可以被多个并发的程序使用。有两种方式：同时访问，互斥访问<br><strong>异步：</strong>进程的执行不是一贯到底，而是走走停停，以不可预知的速度推进。<br><strong>虚拟：</strong>把物理上一个实体变成逻辑上的多个对应物，提供易于使用，方便高效的操作环境</p>
<ol start="3">
<li><strong>什么是操作系统的基本功能？并简单论述</strong></li>
</ol>
<p>管理和控制计算机硬软件资源，合理组织计算机工作流程。基本功能包括：处理机管理、内存管理、设备管理、文件系统、和用户接口等。</p>
<p><strong>处理机管理：</strong>进程控制，作业的创建、撤销和状态转换。进程同步，对诸进程的运行进行调节。进程通信，在相互合作的进程之间的信息交换。调度，作业调度，从后备队列中选出若干作业，分配必要资源；进程调度，从就绪队列中选出新进程，分配处理机，设置运行现场投入运行。<br><strong>内存管理：</strong>内存分配，为程序合理地分配内存空间，合理利用当前内存空间，在需要时为程序申请增加内存空间。内存保护，确保程序在自己的内存空间中运行，互不干扰。地址映射，将逻辑地址转换为物理地址。内存扩充，虚拟存储技术，从逻辑上扩充内存容量。<br><strong>设备管理：</strong>缓冲管理，设备分配和设备处理，以及虚拟设备等。完成用户提出的 I&#x2F;O 请求，为用户分配 I&#x2F;O 设备；提高 CPU 和 I&#x2F;O 设备的利用率；提高 I&#x2F;O 速度；以及方便用户使用 I&#x2F;O 设备。<br><strong>文件管理：</strong>对文件存储管理，目录管理，文件读写管理，以及文件的共享和保护，保证文件安全性。<br><strong>用户接口：</strong>为用户提供灵活方便地使用计算机的手段，一种是程序级接口，一种是作业级接口。</p>
<ol start="4">
<li><strong>操作系统各功能对应的物理设备分别有哪些？</strong></li>
</ol>
<p>处理机管理：处理机。分配实施，资源回收，分配调度策略；<br>内存管理：内存。内存分配，保护，扩充和管理；<br>设备管理： I&#x2F;O 设备，通道，DMA控制器等。分配和管理；<br>文件管理：软件资源。软件资源逻辑结构，物理结构的分配和管理；<br>用户接口：用户。为用户提供灵活方便地使用计算机的手段。</p>
<ol start="5">
<li><strong>什么是批处理、分时和实时系统？各有什么特征？</strong></li>
</ol>
<p>批处理系统：操作员把作业分类，编成一个执行序列，由监督程序自动依次处理。特征：用户脱机使用计算机，成批处理，多道程序运行。<br>分时系统：处理机运行时间分成很短的时间片，按时间片轮转的方式，把处理机分配给各进程使用。特征：交互性，多用户同时性，独立性。<br>实时系统：在被控对象允许时间范围内做出响应。特征：对实时信息分析处理速度比进入系统快，安全可靠，资源利用率低。</p>
<ol start="6">
<li><strong>并发和并行的区别与联系</strong></li>
</ol>
<p>并发：多个事件<u>同一时间段</u>发生。指一段时间内，多个程序快速交替执行，宏观上看起来是同时进行。宏观上同时发生，微观上一个时刻只有一个程序运行。<br>并行：多个事件<u>同一时刻</u>发生。如果计算机系统有多个处理器，程序可以被分配到多个处理器上，是真正的同时执行。</p>
<ol start="7">
<li><strong>多道程序设计和多重处理有什么区别？</strong></li>
</ol>
<p>多道程序设计：作业之间自动调度执行，共享系统资源，不是真正的的同时执行多个作业。<br>多重处理：配置多个CPU，真正同时执行多个程序。</p>
<p>要有效使用多重处理，必须使用多道程序设计，但是多道程序设计原则上不一定要多重处理的支持。</p>
<p>8.<br>9. <strong>试从交互性、及时性以及可靠性方面，将分时系统与实时系统进行比较。</strong></p>
<p>交互性：实时信息系统具有交互性，但人与系统的交互仅限于访问系统中某些<u>特定的专用服务程序</u>。不像分时系统那样能向终端用户<u>提供数据和资源共享</u>等服务。<br>及时性：实时信息处理系统对实时性的要求与分时系统类似，都是以<u>人所能接受的等待时间</u>来确定；但实时系统的及时性，是以<u>控制对象所要求的开始截止时间或完成截止时间</u>来确定的。<br>可靠性：实时系统有更高度的可靠性。实时系统任何差错都可能带来巨大损失，因此往往采取了多级容错措施保障系统的安全性与数据的安全性。</p>
<ol start="10">
<li><strong>考察一个小的嵌入式操作系统或物联网系统，写出系统引导和操作系统加载过程。</strong></li>
</ol>
<p>两个阶段。</p>
<p>第一阶段：<br>a. 硬件设备初始化。屏蔽所有中断，设置 CPU 速度和时钟频率，RAM 初始化等。<br>b. 为第二阶段引导程序加载准备 RAM 空间。初始化中断向量表。<br>c. 复制第二阶段的二进制代码到 RAM 空间中。<br>d. 设置好堆栈指针，为执行 C 语言代码做好准备。初始化堆栈。<br>e. 跳转到第二阶段。</p>
<p>第二阶段：<br>a. 其他硬件设备的初始化。<br>b. 检测系统内存镜像。<br>c. 将操作系统内核映像及文件系统映像从 Flash 读取到系统 RAM。<br>d. 为操作系统内核设置启动参数<br>e. 调用操作系统内核</p>
<ol start="11">
<li><strong>操作系统的发展历程</strong></li>
</ol>
<p>a. 手工操作阶段。需要人工干预，有严重的缺点，此时尚未形成操作系统。<br>b. 早期联机与脱机批处理。区别在于 I&#x2F;O 是否受主机控制。<br>c. 多道批处理系统中允许多道程序并发执行，与单道批处理系统相比有质的飞跃</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>1.<br>2. <strong>举例说明程序并发执行时为什么会失去封闭性和可再现性？</strong></p>
<p>程序并发执行时，多个程序共享系统中的各种资源，资源共享性会使程序失去封闭性，失去了封闭性就会导致程序失去可再现性。如：</p>
<pre><code class="clike">程序1
...
R1 = X
R1 = R1+1
X = R1
...

程序2
...
R2 = X
R2 = R2 + 1
X = R2
...
</code></pre>
<ol start="3">
<li><strong>论述进程和程序的区别与联系</strong></li>
</ol>
<p>动态性：进程动态，程序静态；进程强调执行的过程，程序是静态实体，指令的有序集合，无执行含义。<br>并发性：引入进程的目的就是使程序能和其他进程的程序并发执行，而程序无法并发执行。<br>独立性：进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。而未建立进程的程序不能作为一个独立的单位运行。<br>不同的进程可以包含同一个程序，同一程序在执行中也可以产生多个进程。</p>
<ol start="4">
<li><strong>进程有几种状态？并说明进程在不同状态之间转换的过程和原因</strong></li>
</ol>
<p>基本为三态（运行、就绪、阻塞）或五态（运行、就绪、阻塞、创建、结束）</p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231126215718496.png" alt="image-20231126215718496"></p>
<p>三态图</p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231126215629695.png" alt="image-20231126215629695"></p>
<p>五态图</p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231126220107135.png" alt="image-20231126220107135"></p>
<ol start="5">
<li><strong>什么是原语？进程控制语句都有哪些，并简要说明</strong></li>
</ol>
<p>原子性，由若干条指令组成的，用于完成某一特定功能的一段程序，具有不可分割性。即必须是连续的，在执行过程中不允许被中断。</p>
<p>创建原语，撤销原语，阻塞原语，唤醒原语。</p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231126221053631.png" alt="image-20231126221053631"></p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231126221101843.png" alt="image-20231126221101843"></p>
<ol start="6">
<li><strong>什么使进程间的互斥？什么是进程间同步？使用 P，V 操作举例说明互斥和同步的实现。</strong></li>
</ol>
<p>互斥：一组进程中的一个或多个程序段，因<u>共享某一共有资源</u>而导致它们必须以一个<u>不许交叉执行</u>的单位执行，即不允许两个以上的共享该资源的并发进程<u>同时进入临界区</u>。</p>
<p>同步：异步环境下的一组并发进程因直接制约互相发送消息而进行互相合作、互相等待,各进程按一定的速度执行的过程。</p>
<pre><code class="pseudocode">var mutex, empty, full: psemaphore;
i, j, goods: integer; buffer: array[0..n-1] of item;
procedure producer;
    begin
        while true do
        begin
        //produce next preduct
        P(empty);
        P(mutex);
        buffer(i) := product;
        i := (i+1)mod(n);
        V(mutex);
        V(full);
    end
end;
</code></pre>
<p>7.<br>8.<br>9.<br>10.<br>11. <strong>什么是线程？试述线程与进程的区别。</strong></p>
<p>线程是进程内用于调度和占有处理机的基本单位。由<u>线程控制表、存储线程上下文的用户栈以及核心栈</u>组成。线程可分为用户级线程、核心级线程以及用户&#x2F;核心混合型线程等类型。</p>
<p>用户级线程 在用户态下执行，CPU调度算法和各线程优先级都由用户设置，与操作系统内核无关。（内核态不感知）<br>核心级线程 的调度算法及线程优先级的控制权在操作系统内核。<br>混合型线程 的控制权则在用户和操作系统内核二者。</p>
<p><strong>区别：</strong><br>资源：进程是资源管理的基本单位，拥有自己的地址空间和各种资源；线程是处理机调度的基本单位，与其他线程一起共享进程资源，自己没有任何资源。<br>开销：以进程为单位进行处理机切换和调度时，由于涉及<u>资源转移以及现场保护</u>等问题，处理机切换<u>时间较长，资源利用率较低</u>。以线程为单位进行处理机切换和调度时，由于几乎<u>不发生资源变化</u>，特别是地址空间的变化，处理机切换<u>时间较短，资源利用率较高</u>。<br>效率：如果支持多线程，则可以在同一进程中使用多个线程同时执行，减少等待时间，提高系统的响应速度。如果不支持多线程，需要顺序等待执行结束，且期间易发生进行调度，开销较大。<br>状态：线程<u>没有单独的数据和程序空间</u>，因此不能像进程的数据和程序那样，交换到外存存储空间，从而线程<u>没有挂机状态</u>。<br>控制：进程的调度、同步等控制大多由操作系统内核完成，而线程的控制既可以由操作系统内核进行，也可以由用户控制进行。</p>
<ol start="12">
<li><strong>在创建一个进程时所要完成的主要工作是什么？</strong></li>
</ol>
<p>a. OS发现请求创建进程事件后，调用进程创建原语 Create();<br>b. 申请空白 PCB ;<br>c. 为新进程分配资源;<br>d. 初始化进程控制块;<br>e. 将新进程插入就绪队列;</p>
<ol start="13">
<li><strong>在撤销一个进程时所要完成的主要工作是什么？</strong></li>
</ol>
<p>a. 根据被终止进程标识符，从 PCB 中检索出进程 PCB ，读出该进程状态。<br>b. 若终止进程处于执行状态，立即终止该进程的执行，置调度标志真，指示该进程被终止后重新调度。<br>c. 若该进程还有子进程，应将所有子孙进程终止，以防它们成为不可控进程。<br>d. 将被终止进程拥有的全部资源，归还给父进程，或归还给系统。<br>e. 将被终止进程PCB从所在队列或列表中移出，等待其他程序搜集信息。</p>
<p>14. </p>
<ol start="15">
<li><strong>为什么要在 OS 中引入线程？</strong></li>
</ol>
<p>进程 是分配资源的基本单位,而线程则是系统调度的基本单位。减少程序在并发执行时所付出 的时空开销，使 OS 具有更好的并发性，提高 CPU 的利用率。 </p>
<ol start="16">
<li>1</li>
<li>1</li>
<li>1</li>
<li>**原子操作与临界区的区别是什么？ **</li>
</ol>
<p>原子操作：由处理器保证的不可分割的操作。对于简单的原子操作，处理器会提供单条指令以保证原子性；对于复杂的源自操作，通过添加自旋锁来实现执行过程不被打断。<br>临界区：不允许多个并发进程交叉执行的一段程序。临界区的实现方式，在临界区设置和检查访问标志。进程访问临界区时，通过访问标志判断临界区是否有其他进程在访问。如果有，则等待并循环检查；如果没有，则进入临界区。进程离开临界区时重置访问标志。</p>
<ol start="20">
<li><strong>简述 P、V 原语和加锁法实现进程间互斥的区别</strong>？？？？？？？？？？？？？？？？</li>
</ol>
<p>P、V 原语实现：采用<u>信号量</u>管理相应临界区的共有资源，信号量的数值仅能由 P、V 原语操作改变，而 P、V 原语执行期间<u>不允许中断发生</u>。</p>
<ol start="21">
<li>1</li>
<li>1</li>
<li></li>
</ol>
<h2 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h2><ol>
<li>**什么是调度？什么是分级调度？分时系统中有作业调度的概念吗？如果没有，为什么? **</li>
</ol>
<p>处理机调度：指动态地把CPU分配给并发执行的进程。处理机调度实际上就是处理机的分配问题。进程只有取得除处理机以外的各种资源后才能参与处理机的竞争，所以在这以前，要为此作好准备，故要采用的是分级调度。<br>分级调度：就是把一项任务按照一定的步骤分解开来，或者由上到下、由高到低、由简单到复杂（反之亦然），按照一定的计划逐步进行“调兵遣将”执行并最终完成某项工作。<br>分级：作业调度；交换调度；进程调度；线程调度；</p>
<p>分时系统无作业调度。在分时系统中，为缩短响应时间，作业建立在内存，故无提交和后备状态。一旦用户和系统的交互开始，用户要马上进行控制。</p>
<ol start="2">
<li><p>1</p>
</li>
<li><p>1</p>
</li>
<li><p>4</p>
</li>
<li><p>5</p>
</li>
<li><p><strong>何谓死锁?产生死锁的原因和必要条件是什么?</strong></p>
</li>
</ol>
<p>死锁：多个进程因竞争资源造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进。<br>原因：竞争资源，进程推进顺序非法<br>必要条件：互斥条件，请求和保持条件，不剥夺条件和环路等待条件。</p>
<ol start="7">
<li><strong>请详细说明可通过哪些统计预防死锁</strong></li>
</ol>
<p>a. 如果系统有足够的资源，直接一次性分配所有所需资源。<br>b. 已经保持了资源的进程，当其提出新的资源请求而不能立即得到满足时，必须释放它保持的所有资源，待以后需要时再重新申请。<br>c. 将所有资源按类型排序标号，所有进程对资源的请求必须严格按序号递增次序提出。</p>
<p>8. </p>
<ol start="9">
<li><strong>何为作业、作业步和作业流？</strong></li>
</ol>
<p>作业：包含通常的程序和数据，还配有作业说明书。系统根据说明书对程序的运行进行控制。批处理系统中是以作业为基本单位从外存调入内存。<br>作业步：每个作业运行期间都必须经过若干个相对独立互相关联的顺序加工的步骤。<br>作业流：若干个作业在进入系统后依次存放在外村上形成的输入作业流；在操作系统的控制下，逐个作业进程处理，形成了处理作业流。</p>
<p>10. </p>
<ol start="11">
<li><strong>试比较 FCFS 和 SPF 两种进程调度算法。</strong></li>
</ol>
<p>同：都可以用于作业调度和进程调度。（页表那边叫FIFO，差不多意思）<br>异：<br>FCFS：每次都从后备队列中选择一个或多个<u>最先进入</u>该队列的作业，将它们调入内存、分配资源、创建进程、插入到就绪队列。有利于长作业&#x2F;进程，不利于短作业&#x2F;进程。<br>SPF：每次从后备队列中选择一个或多个<u>估计运行时间最短</u>的作业，调入内存运行。该算法有利于短作业&#x2F;进程，不利于长作业&#x2F;进程。</p>
<ol start="12">
<li><p>12</p>
</li>
<li><p>13</p>
</li>
</ol>
<h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><ol>
<li><p>1</p>
</li>
<li><p>2</p>
</li>
<li><p>3</p>
</li>
<li><p>4</p>
</li>
<li><p>5</p>
</li>
<li><p>6</p>
</li>
<li><p><strong>什么是段式管理?其与页式管理的有何区别（请至少举例说明三 点）? （段式管理即分段存储管理，页式管理即分页存储管理）</strong></p>
</li>
</ol>
<p>段式管理：将程序按照内容或过程（函数）关系分成段，每段拥有自己的名字。一个用户作业或进程所包含的段对应于一个二维线性虚拟空间，也就是一个二维虚拟存储器。段式管理程序以段为单位分配内存，然后通过地址映射机构把段式虚拟地址转换成实际的内存物理地址。<br>同页式管理类似，段式管理也采用只把经常访问的段驻留内存，而把那些在将来一段时间内不被访问的段放入外村，待需要时自动调入相关段的方法实现二维虚拟存储器。</p>
<p><strong>区别：</strong></p>
<p>a. 编译<br>页式管理：源程序进行编译连接时是将主程序、子程序、数据区等按照线性空间的一维地址顺序排列起来。<br>段式管理：将程序按照内容或过程（函数）关系分成段，每段拥有自己的名字。一个用户作业或进程所包含的段对应于一个二维线性虚拟空间，也就是一个二维虚拟存储器。</p>
<p>b. 虚拟存储<br>段式管理：每次交换的是一次有意义的信息<br>页式管理：只交换固定大小的页，需要多次的缺页中断，才能把所需信息完整地调入内存</p>
<p>c.<br>段式管理：可根据需要动态增长</p>
<p>d.<br>段式管理：对于具有完整逻辑功能的信息段进行共享</p>
<p>e.<br>段式管理：便于进行动态链接<br>页式管理：动态链接过程非常复杂</p>
<ol start="8">
<li><strong>试全面比较连续分配和离散分配存储器管理方式</strong></li>
</ol>
<p><strong>连续分配：</strong><br>为一个用户程序分配一个连续的地址空间，包括单一连续分配方式和分区式分配方式。</p>
<ul>
<li>单一分配方式：<br>将内存分为系统区和用户区，系统区供操作系统使用，用户区供用户使用，是最简单的一种存储方式，但只能用于单用户单任务的操作系统中</li>
<li>分区式分配方式：<br>分区式分配方式分为固定分区和动态分区<ul>
<li>固定分区：<br>最简单的多道程序的存储管理方式，由于每个分区的<u>大小固定</u>，必然会造成存储空间的<u>浪费</u></li>
<li>动态分区：<br>根据进程<u>实际需要</u>，<u>动态地</u>为之分配<u>连续</u>的内存空间。有三种分配算法，首次适应算法，循环首次适应算法，最佳适应算法。</li>
</ul>
</li>
</ul>
<p><strong>离散分配：</strong></p>
<p>基于将一个进程直接分散地分配到许多不相邻的分区中的思想，分为 分页式存储管理，分段式存储管理，段页式存储管理。</p>
<ul>
<li><strong>分页式存储管理</strong><br>旨在提高内存利用率，满足系统管理的需要。</li>
<li><strong>分段式内存管理</strong><br>旨在满足用户（程序员）的需要，在实现共享和保护方面优于分页式存储管理。</li>
<li><strong>段页式存储管理</strong><br>结合两者，取长补短，即具有分段系统便于实现，可共享，易于保护，可动态链接等有点，又能像分页系统那样很好的解决外部碎片的问题，以及各个分段可离散分配内存等问题，显然是一种比较有效的存储管理方式。</li>
</ul>
<ol start="9">
<li><strong>实现地址重定位的方法有几类？试列举其各自的特点</strong></li>
</ol>
<p>两种：静态地址重定位和动态地址重定位</p>
<ul>
<li>静态地址重定位：<br>程序执行<u>之前</u>，由装配程序完成地址映射工作。<ul>
<li>优点：不需要硬件支持。</li>
<li>缺点：无法实现虚拟存储器，必须占用连续的内存空间和难以做到程序和数据的共享。</li>
</ul>
</li>
<li>动态地址重定位：<br>程序执行<u>过程中</u>，在 CPU 访问内存之前由硬件地址变换机构将要访问的程序或数据地址转换为内存地址。<ul>
<li>优点：提供了实现虚拟存储器的基础，可以对内存进行非连续分配，有利于程序段的共享</li>
</ul>
</li>
</ul>
<p>10. </p>
<p>11. </p>
<ol start="12">
<li><strong>何为静态链接？何谓装入时动态链接和运行时的动态链接？</strong></li>
</ol>
<ul>
<li><strong>静态链接</strong><br><u>程序运行前</u>，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开的方式。</li>
<li><strong>动态链接</strong><ul>
<li><strong>装入时动态链接</strong><br>将用户源编译后得到的一组目标模块，在转入内存时采用边装入边链接的链接方式。</li>
<li><strong>运行时动态链接</strong><br>对某些目标模块的链接，是在<u>程序执行中需要该目标模块</u>时，才对它进行的链接。</li>
</ul>
</li>
</ul>
<ol start="13">
<li><strong>分区存储管理中常用哪些分配策略？比较它们的优缺点。</strong></li>
</ol>
<ul>
<li><strong>首次适应算法</strong><ul>
<li>优点：保留了高址部分的大空闲区，利于后来的<u>大作业分配</u></li>
<li>缺点：留下许多<u>难以利用的小空闲区</u>，每次查找都从低址开始<u>增加了系统开销</u>。</li>
</ul>
</li>
<li><strong>循环首次适应算法</strong><ul>
<li>优点：内存空间<u>分布均匀</u>，<u>减少</u>了系统查找<u>开销</u></li>
<li>缺点：缺乏<u>大空闲分区</u>，导致<u>不能装入大型作业</u></li>
</ul>
</li>
<li><strong>最佳适应算法</strong><ul>
<li>优点：每次分配给文件的都是最<u>适合该文件大小的分区</u></li>
<li>缺点：留下许多<u>难以利用的小空闲区</u></li>
</ul>
</li>
<li><strong>最坏适应算法</strong><ul>
<li>优点：剩下空闲区都不太小，产生<u>碎片几率小</u>，对<u>中小型文件</u>分配分区操作有利</li>
<li>缺点：存储器中<u>缺乏大空闲区</u>，对大型文件分区不利</li>
</ul>
</li>
</ul>
<ol start="14">
<li><strong>分段和分页存储管理有何区别？</strong></li>
</ol>
<p>a.<br>页是信息的物理单位，分页时为了实现<u>离散分配方式</u>，以消减内存的外部零头，<u>提高内存利用率</u>。<br>段是信息的逻辑单位，它含有一组<u>相对完整的信息</u>。</p>
<p>b.<br>页的<u>大小固定</u>且由<u>系统决定</u>，由系统把逻辑地址划分为<u>页号和页内地址</u>两部分，是由机械硬件实现的，因而在系统中<u>只能有一种大小的页面</u>。<br>段的<u>长度不固定</u>，<u>决定于用户</u>所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p>
<p>c.<br>分页的作业地址空间是<u>一维</u>，<br>分段的作业地址空间是<u>二维</u>。</p>
<ol start="15">
<li><p>15</p>
</li>
<li><p>16</p>
</li>
<li><p>17</p>
</li>
<li><p>存储器有关概念</p>
</li>
</ol>
<ul>
<li><strong>逻辑地址</strong><br>用户程序经编译之后的每个目标模块都以0为基地址顺序编址</li>
<li><strong>物理地址</strong><br>内存中各物理单元的地址是从统一的基地址顺序编址。</li>
<li><strong>重定位</strong><br>把逻辑地址转变为内存的物理地址的过程。</li>
<li><strong>静态重定位</strong><br>在目标程序装入内存时，由装入程序对目标程序中的指针和数据的地址进行修改，即把程序的逻辑地址都改成实际的内存地址。重定位在程序装入时一次完成</li>
<li><strong>动态重定位</strong><br>在程序执行期间，每次访问内存之间进行重定位，这种变换是靠硬件地址变换机构实现的。</li>
</ul>
<ol start="19">
<li><strong>虚拟内存中的置换算法</strong></li>
</ol>
<ul>
<li><strong>先进先出（FIFO）</strong>（FCFS貌似是进程作业那边的说法，差别不大）<br>换出<u>最先进入</u>内存的页。</li>
<li><strong>最佳置换（OPT）</strong><br>换出<u>将来不再被使用</u>或<u>最远的将来</u>才被访问的页。</li>
<li><strong>最近最少使用算法（LRU）</strong><br>换出<u>最近一段时间最久没有使用过</u>的页。</li>
<li><strong>最近未使用置换法（NUR）</strong>LRU 的近似方法，易实现，开销小<br>在存储分块表的<u>每一表项中增加一个引用位</u>，操作系统定期将他们置为0。当某一页被<u>访问时</u>，由硬件将该位<u>置为1</u>。需要淘汰一页时，把<u>该位为0的页淘汰</u>出去。</li>
</ul>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><ol>
<li><strong>数据传送控制方式有哪几种？试比较它们各自的优缺点。</strong></li>
</ol>
<ul>
<li><strong>程序直接控制方式</strong><br>用户进程<u>直接控制</u>内存或CPU和外围设备之间的数据传送。<ul>
<li>优点：控制<u>简单，</u>不需要多少硬件支持</li>
<li>缺点：CPU<u>浪费大量时间等待</u>设备输入输出，CPU和外围设备只能<u>串行</u>工作。</li>
</ul>
</li>
<li><strong>中断控制方式</strong><br>利用向 CPU 发送<u>中断</u>的方式控制外围设备和 CPU 之间的数据传送<ul>
<li>优点：大大<u>提高</u>了 CPU 的<u>利用率</u>，且支持多道程序和设备的<u>并行</u>操作。</li>
<li>缺点：<ul>
<li>由于数据缓冲<u>寄存器比较小</u>，如果中断次数较多，仍然占用了大量 CPU 时间；</li>
<li>外围<u>设备较多</u>时，由于中断次数的急剧增加，可能造成 CPU 无法响应中断而出现<u>中断丢失</u>的现象；</li>
<li>如果<u>外围设备比较快</u>，可能会出现 CPU 来不及从数据缓冲寄存器中取走数据而<u>丢失数据</u>的情况；</li>
<li>每次传输的数据量以字节为单位，<u>效率较低</u>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>DMA 方式</strong><br>在<u>外围设备和内存之间</u>开辟直接的<u>数据交换通路</u>进行数据传送。<ul>
<li>优点：<ul>
<li>除了数据在数据块传送开始时需要 CPU 的启动指令，在整个数据块传送结束时需要发中断通知 CPU 进行中断处理之外，不需要 CPU 的频繁干涉。</li>
<li>以数据块为单位，效率较高。</li>
</ul>
</li>
<li>缺点：<ul>
<li>外围设备越来越多的情况下，多个DMA控制器同时使用，会引起内存地址的冲突使得控制过程进一步复杂化。</li>
</ul>
</li>
</ul>
</li>
<li><strong>通道方式</strong><br>使用<u>通道</u>来控制<u>内存或 CPU 和外围设备之间</u>的数据传送。通道是一个独立于 CPU 的专门负责输入输出控制的机构，它控制设备于内存直接进行数据交换。<ul>
<li>优点：<ul>
<li>进一步<u>减轻</u>了 CPU 的<u>工作负担</u>，增加了计算机系统的<u>并行</u>工作程度；</li>
<li>每次可以传输<u>一组</u>数据块，<u>效率最高</u>；</li>
</ul>
</li>
<li>缺点：增加了<u>额外的硬件</u>，造假昂贵。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>试列举常用的硬盘调度算法，并说明其主要特点</strong></li>
</ol>
<ul>
<li><p><strong>先来先服务（FCFS）</strong><br>根据进程请求访问硬盘的<u>先后顺序</u>进行调度。</p>
<ul>
<li>具有公平性，少量进程需要访问且大部分是簇聚的文件扇区，则有望达到较好的性能。</li>
<li>如果由大量进程竞争使用硬盘，性能上接近随机调度</li>
</ul>
</li>
<li><p><strong>最短寻找时间有限（SSTF）</strong><br>选择调度处理的磁道是与<u>当前磁头所在磁道距离最近</u>的磁道，以使每次的<u>寻找时间最短</u>。</p>
<ul>
<li>每次寻找时间最小不能保证平均最小，但是能提供比FCFS更好的性能，但是该算法会产生 “饥饿” 现象。</li>
</ul>
</li>
<li><p><strong>扫描（SCAN，又称电梯算法）</strong><br>在磁头<u>当前移动方向</u>上选择与<u>当前磁头所在磁道距离最近</u>的磁道。实际上就是SSTF的基础上规定移动方向为当前移动方向。</p>
<ul>
<li>对最近扫描过的区域不公平，局部性方面不如 FCFS 和 SSTF 。</li>
<li>总是严格地从盘面的一端到另一端</li>
</ul>
</li>
<li><p><strong>循环扫描（C-SCAN）</strong></p>
<p>在扫描算法的基础上规定磁头单项移动来提供服务，回返时<u>直接快速移动至起始端</u>而<u>不服务任何请求</u>。</p>
<ul>
<li>总是严格地从盘面的一端到另一端</li>
</ul>
</li>
<li><p><strong>LOOK 和 C-LOOK</strong><br>改进的 SCAN 和 C-SCAN，只是磁头移动只需要到达<u>最远端的一个请求即可返回，不需要到达磁盘端点</u>。</p>
</li>
</ul>
<ol start="3">
<li><p>3</p>
</li>
<li><p><strong>为什么要引入设备独立性？试说明如何实现设备独立性</strong><br>提高系统的可适应性和可扩展性，实现设备独立性。应用程序独立于具体使用的物理设备，即应用程序以逻辑设备名称来使用某类设备。</p>
</li>
</ol>
<ul>
<li><p>优点：</p>
<ul>
<li>设备分配时的灵活性</li>
<li>易于实现 I&#x2F;O 重定向</li>
</ul>
</li>
<li><p>实现：<br>逻辑设备，物理设备。在应用程序中，使用逻辑设备名称来请求使用某类设别；系统执行时是使用物理设备名称。</p>
<ul>
<li>鉴于驱动程序是一个与硬件（或设备）紧密相关的软件，必须在驱动程序之上设置一层软件，称为设备独立性软件，以执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换并向用户层软件提供统一接口，从而实现设备独立性。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>在设备分配中，什么是安全分配方式和不安全分配方式？请说明其特点</strong></li>
</ol>
<ul>
<li><strong>安全分配方式</strong><br>每当进程发出 I&#x2F;O 请求后，便进入阻塞状态，直到其 I&#x2F;O 操作完成时才被唤醒。</li>
</ul>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a><strong>文件管理</strong></h2><h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h2>
    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2023 - 2023 ⭐星雨起源⭐
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;海画沙夢w
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>



        <script src="/js/main.js">  </script>
        <script>
            console.info("Welcome to Argvchs' blog!");
            if (!window.hasOwnProperty("ontouchstart")) {
                let html = '<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas><script src="https://static-argvchs.netlify.app/js/fireworks.min.js"><\/script>';
                document.body.append(document.createRange().createContextualFragment(html));
            }
        </script>


        <!-- 鼠标点击特效 -->
        <canvas
            id="fireworks"
            style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
        ></canvas>
        <script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
        <script src="/js/fireworks.min.js"></script>



        <!-- 鼠标指针特效 -->
        <div id="cursor"></div>
        <link rel="stylesheet" href="/css/cursor.min.css" />
        <script src="/js/cursor.min.js"></script>



        <!-- 流星背景特效 -->
        <canvas
            id="background"
            style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
        ></canvas>
        <script src="/js/background.min.js"></script>




       



        
        
<script
    src="https://giscus.app/client.js"
    data-repo="StaRainorigin/StaRainorigin.github.io"
    data-repo-id="R_kgDOH6wiAg"
    data-category="General"
    data-category-id="DIC_kwDOH6wiAs4CY_KG"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="https://static-argvchs.netlify.app/css/giscus.css"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
