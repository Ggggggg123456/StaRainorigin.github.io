
<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8" />
        <title>操作系统期末复习 | ⭐星雨起源⭐</title>
        <meta name="author" content="海画沙夢w" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/favicon.png" />
        <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>⭐星雨起源⭐</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;⭐星雨起源⭐</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div class="article">
    <div>
        <h1>操作系统期末复习</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/11/26
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="color: #03a9f4">操作系统</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" style="color: #00bcd4">期末复习</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="操作系统期末复习"><a href="#操作系统期末复习" class="headerlink" title="操作系统期末复习"></a>操作系统期末复习</h1><h2 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h2><ol>
<li><strong>设计现代OS的主要目标是什么？</strong></li>
</ol>
<p>有效性，方便性，可扩充性，开放性，</p>
<ol start="2">
<li><strong>什么是操作系统？操作系统的基本特征是什么？并简单论述</strong></li>
</ol>
<p>系统软件，管理和控制计算机硬软件资源，合理组织计算机工作流程。特征包括：并发，共享，异步，虚拟。 其中并发和共享是最基本特征。</p>
<ul>
<li><strong>并发：</strong>多个事件可以同一个时间间隔内发生，可以同时处理和调度多个程序</li>
<li><strong>共享：</strong>资源可以被多个并发的程序使用。有两种方式：同时访问，互斥访问</li>
<li><strong>异步：</strong>进程的执行不是一贯到底，而是走走停停，以不可预知的速度推进。</li>
<li><strong>虚拟：</strong>把物理上一个实体变成逻辑上的多个对应物，提供易于使用，方便高效的操作环境</li>
</ul>
<ol start="3">
<li><strong>什么是操作系统的基本功能？并简单论述</strong></li>
</ol>
<p>管理和控制计算机硬软件资源，合理组织计算机工作流程。基本功能包括：处理机管理、内存管理、设备管理、文件系统、和用户接口等。</p>
<ul>
<li><strong>处理机管理</strong><br>进程控制，作业的创建、撤销和状态转换。进程同步，对诸进程的运行进行调节。进程通信，在相互合作的进程之间的信息交换。调度，作业调度，从后备队列中选出若干作业，分配必要资源；进程调度，从就绪队列中选出新进程，分配处理机，设置运行现场投入运行。</li>
<li><strong>内存管理</strong><br>内存分配，为程序合理地分配内存空间，合理利用当前内存空间，在需要时为程序申请增加内存空间。内存保护，确保程序在自己的内存空间中运行，互不干扰。地址映射，将逻辑地址转换为物理地址。内存扩充，虚拟存储技术，从逻辑上扩充内存容量。</li>
<li><strong>设备管理</strong><br>缓冲管理，设备分配和设备处理，以及虚拟设备等。完成用户提出的 I&#x2F;O 请求，为用户分配 I&#x2F;O 设备；提高 CPU 和 I&#x2F;O 设备的利用率；提高 I&#x2F;O 速度；以及方便用户使用 I&#x2F;O 设备。</li>
<li><strong>文件管理</strong><br>对文件存储管理，目录管理，文件读写管理，以及文件的共享和保护，保证文件安全性。</li>
<li><strong>用户接口</strong><br>为用户提供灵活方便地使用计算机的手段，一种是程序级接口，一种是作业级接口。</li>
</ul>
<ol start="4">
<li><strong>操作系统各功能对应的物理设备分别有哪些？</strong></li>
</ol>
<ul>
<li><strong>处理机管理</strong><br>处理机。分配实施，资源回收，分配调度策略；</li>
<li><strong>内存管理</strong><br>内存。内存分配，保护，扩充和管理；</li>
<li><strong>设备管理</strong><br> I&#x2F;O 设备，通道，DMA控制器等。分配和管理；</li>
<li><strong>文件管理</strong><br>软件资源。软件资源逻辑结构，物理结构的分配和管理；</li>
<li><strong>用户接口</strong><br>用户。为用户提供灵活方便地使用计算机的手段。</li>
</ul>
<ol start="5">
<li><strong>什么是批处理、分时和实时系统？各有什么特征？</strong></li>
</ol>
<ul>
<li><strong>批处理系统</strong><br>操作员把作业分类，编成一个执行序列，由监督程序自动依次处理。特征：用户脱机使用计算机，成批处理，多道程序运行。</li>
<li><strong>分时系统</strong><br>处理机运行时间分成很短的时间片，按时间片轮转的方式，把处理机分配给各进程使用。特征：交互性，多用户同时性，独立性。</li>
<li><strong>实时系统</strong><br>在被控对象允许时间范围内做出响应。特征：对实时信息分析处理速度比进入系统快，安全可靠，资源利用率低。</li>
</ul>
<ol start="6">
<li><strong>并发和并行的区别与联系</strong></li>
</ol>
<ul>
<li><strong>并发</strong><br>多个事件<u>同一时间段</u>发生。指一段时间内，多个程序快速交替执行，宏观上看起来是同时进行。宏观上同时发生，微观上一个时刻只有一个程序运行。</li>
<li><strong>并行</strong><br>多个事件<u>同一时刻</u>发生。如果计算机系统有多个处理器，程序可以被分配到多个处理器上，是真正的同时执行。</li>
</ul>
<ol start="7">
<li><strong>多道程序设计和多重处理有什么区别？</strong></li>
</ol>
<p>多道程序设计：作业之间自动调度执行，共享系统资源，不是真正的的同时执行多个作业。<br>多重处理：配置多个CPU，真正同时执行多个程序。</p>
<p>要有效使用多重处理，必须使用多道程序设计，但是多道程序设计原则上不一定要多重处理的支持。</p>
<p>8.<br>9. <strong>试从交互性、及时性以及可靠性方面，将分时系统与实时系统进行比较。</strong></p>
<p>交互性：实时信息系统具有交互性，但人与系统的交互仅限于访问系统中某些<u>特定的专用服务程序</u>。不像分时系统那样能向终端用户<u>提供数据和资源共享</u>等服务。<br>及时性：实时信息处理系统对实时性的要求与分时系统类似，都是以<u>人所能接受的等待时间</u>来确定；但实时系统的及时性，是以<u>控制对象所要求的开始截止时间或完成截止时间</u>来确定的。<br>可靠性：实时系统有更高度的可靠性。实时系统任何差错都可能带来巨大损失，因此往往采取了多级容错措施保障系统的安全性与数据的安全性。</p>
<ol start="10">
<li><strong>考察一个小的嵌入式操作系统或物联网系统，写出系统引导和操作系统加载过程。</strong></li>
</ol>
<p>两个阶段。</p>
<p>第一阶段：<br>a. 硬件设备初始化。屏蔽所有中断，设置 CPU 速度和时钟频率，RAM 初始化等。<br>b. 为第二阶段引导程序加载准备 RAM 空间。初始化中断向量表。<br>c. 复制第二阶段的二进制代码到 RAM 空间中。<br>d. 设置好堆栈指针，为执行 C 语言代码做好准备。初始化堆栈。<br>e. 跳转到第二阶段。</p>
<p>第二阶段：<br>a. 其他硬件设备的初始化。<br>b. 检测系统内存镜像。<br>c. 将操作系统内核映像及文件系统映像从 Flash 读取到系统 RAM。<br>d. 为操作系统内核设置启动参数<br>e. 调用操作系统内核</p>
<ol start="11">
<li><strong>操作系统的发展历程</strong></li>
</ol>
<p>a. 手工操作阶段。需要人工干预，有严重的缺点，此时尚未形成操作系统。<br>b. 早期联机与脱机批处理。区别在于 I&#x2F;O 是否受主机控制。<br>c. 多道批处理系统中允许多道程序并发执行，与单道批处理系统相比有质的飞跃</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>1.<br>2. <strong>举例说明程序并发执行时为什么会失去封闭性和可再现性？</strong></p>
<p>程序并发执行时，多个程序共享系统中的各种资源，资源共享性会使程序失去封闭性，失去了封闭性就会导致程序失去可再现性。如：</p>
<pre><code class="clike">程序1
...
R1 = X
R1 = R1+1
X = R1
...

程序2
...
R2 = X
R2 = R2 + 1
X = R2
...
</code></pre>
<ol start="3">
<li><strong>论述进程和程序的区别与联系</strong></li>
</ol>
<p>动态性：进程动态，程序静态；进程强调执行的过程，程序是静态实体，指令的有序集合，无执行含义。<br>并发性：引入进程的目的就是使程序能和其他进程的程序并发执行，而程序无法并发执行。<br>独立性：进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。而未建立进程的程序不能作为一个独立的单位运行。<br>不同的进程可以包含同一个程序，同一程序在执行中也可以产生多个进程。</p>
<ol start="4">
<li><strong>进程有几种状态？并说明进程在不同状态之间转换的过程和原因</strong></li>
</ol>
<p>基本为三态（运行、就绪、阻塞）或五态（运行、就绪、阻塞、创建、结束）</p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231126215718496.png" alt="image-20231126215718496"></p>
<p>三态图</p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231126215629695.png" alt="image-20231126215629695"></p>
<p>五态图</p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231126220107135.png" alt="image-20231126220107135"></p>
<ol start="5">
<li><strong>什么是原语？进程控制语句都有哪些，并简要说明</strong></li>
</ol>
<p>原子性，由若干条指令组成的，用于完成某一特定功能的一段程序，具有不可分割性。即必须是连续的，在执行过程中不允许被中断。</p>
<p>创建原语，撤销原语，阻塞原语，唤醒原语。</p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231126221053631.png" alt="image-20231126221053631"></p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231126221101843.png" alt="image-20231126221101843"></p>
<ol start="6">
<li><strong>什么使进程间的互斥？什么是进程间同步？使用 P，V 操作举例说明互斥和同步的实现。</strong></li>
</ol>
<p>互斥：一组进程中的一个或多个程序段，因<u>共享某一共有资源</u>而导致它们必须以一个<u>不许交叉执行</u>的单位执行，即不允许两个以上的共享该资源的并发进程<u>同时进入临界区</u>。</p>
<p>同步：异步环境下的一组并发进程因直接制约互相发送消息而进行互相合作、互相等待,各进程按一定的速度执行的过程。</p>
<pre><code class="c">int in=0, out=0;
item buffer[n];		//item类型，自己定义的
semaphore mutex=1, empty=n, full=0;		//semaphore是信号类型，自己定义的

void producer() &#123;
    do&#123;
        produce an item in nextp;	//从nextp生产出一个item
        ...
        P(empty);
        P(mutex);
        buffer[in] = nextp;
        in = (in+1)%n;
        V(mutex);
        V(full);
    &#125;while(True);
&#125;

void consumer() &#123;
    do&#123;
        P(full);
        P(mutex);
        nextc = buffer[out];
        out = (out+1)%n;
        V(empty);
        V(mutex);
        consume the item in nextc;	//在nextc中消费一个item
        ...
    &#125;while(True);
&#125;

//*******************************************************

void P(semaphore S) &#123;
    while (S&lt;=0) &#123; /*等待*/ &#125;;
    S--;
&#125;

void V(semaphore S) &#123;
    S++;
&#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1BA411W7DL?vd_source=6df2f60423608555adc65c0f2594130d">计算机操作系统（期末必考系列）–进程同步生产者消费者</a></p>
<p>先减full，再上锁，先解锁，再增empty</p>
<ol start="7">
<li><strong>设有 5 个哲学家，共享一张放有五把椅子的桌子，每人分得一把 椅子。但是，桌子上总共只有 5 支筷子，在每人两边分开各放一 支。哲学家们在肚子饥饿时才试图分两次从两边拾起筷子就餐。</strong></li>
</ol>
<p><strong>条件：</strong><br>(1) 只有拿到两支筷子时，哲学家才能吃饭。<br>(2) 如果筷子已在他人手上，则该哲学家必须等待到他人吃完之后才 能拿到筷子。<br>(3) 任一哲学家在自己未拿到两支筷子吃饭之前，决不放下自己手中 的筷子。 </p>
<p><strong>试解答以下问题:</strong><br>(1) 描述一个保证不会出现两个邻座同时要求吃饭的通信算法。 </p>
<pre><code class="c">//信号量 c[0]~c[4],初始值均为 1,分别表示 i 号筷子被拿 (i=0,1,2,3,4)
//int c[5] = &#123;1, 1, 1, 1, 1&#125;;

void send(int i) &#123;
    P(c[i]);
    P(c[(i+1)%5]);
    eat();
    V(c[(i+1)%5]);
    V(c[i]);
&#125;
</code></pre>
<p>(2) 描述一个既没有两邻座同时吃饭，又没有人饿死（永远拿不到 筷子）的算法。在什么情况下，5 个哲学家全部吃不上饭？</p>
<pre><code class="c">//信号量 c[0]~c[4],初始值均为 1,分别表示 i 号筷子被拿 (i=0,1,2,3,4)
//int c[5] = &#123;1, 1, 1, 1, 1&#125;;

void send(int i) &#123;
    if (i%2 == 0) &#123;
        P(c[i]);
        P(c[(i+1)%5]);
        eat();
        V(c[i]);
        V(c[(i+1)%5]);
    &#125; else &#123;
        P(c[(i+1)%5]);
        P(c[i]);
        eat();
        V(c[(i+1)%5]);
        V(c[i]);
    &#125;
&#125;
</code></pre>
<ol start="8">
<li><strong>面包师有很多面包，由 n 个销售人员推销。每个顾客进店后去一个号，并且等待叫号，当一个销售人员空闲下来时，就叫下一个号。试设计一个销售人员和顾客同步算法。</strong></li>
</ol>
<pre><code class="c">int take=0, call=0;	//取号值，叫号值
semaphore mutex_take=1, mutex_call=1;	

consumer() &#123;		//顾客买完就走，所以不用while循环
    进入面包店;
    P(mutex_take);		//上锁
    取号;
    take++;
    V(mutex_take);		//解锁
    等待叫号i并购买面包;
&#125;

seller() &#123;			//销售人员在工作时间内一只销售，加一个while
    while(True) &#123;
        P(mutex_call);		//上锁
        
        if (call&lt;take) &#123;		//确保当前叫的号已经被取出。
            叫号;
            call++;
            V(mutex_call);	//解锁
            销售面包;
        &#125; else &#123;
            V(mutex_call);	//解锁, 每次while只会解锁一次
            休息片刻;
        &#125;
    &#125;
&#125;
</code></pre>
<ol start="9">
<li><strong>工厂有两个生产车间和一个装配车间，两个生产车间分别生产 A、B 两种零件，装配车间的任务是把 A、B 两种零件组装成产品，两个生产车间每生产一个零件后都要分别把它们送到专配车间的货架 F1、F2上，F1 存放零件 A，F2 存放零件B，F1和F2 的容量均可以存放 10 个零件，袋配工人每次从货架上取一个零件 A 和一个零件 B 后组装成产品，请用 P、V 操作进行正确管理。</strong></li>
</ol>
<pre><code class="c">int empty1=10, full1=0, mutex1=1;	//对应货架F1
int empty2=10, full2=0, mutex2=1;	//对应货架F2
//mutex指的是对货架的操控权

producerA() &#123;
    while(True) &#123;
        P(emtpy1);
        P(mutex1);
           将产品 A 存放到 F1 上;
        V(mutex1);
        V(full1);
    &#125;
&#125;

producerB() &#123;
    while(True) &#123;
        P(emtpy2);
        P(mutex2);
           将产品 B 存放到 F2 上;
        V(mutex2);
        V(full2);
    &#125;
&#125;

consumer() &#123;
    while(True) &#123;
        P(full1);
        P(mutex1);
        从货架F1上取一个A产品;
        V(empty1);
        V(mutex1);
        
        P(full2);
        P(mutex2);
        从货架F2上取一个B产品;
        V(mutex2);
        V(empty2);
        将F1与F2拼装;
    &#125;
&#125;
</code></pre>
<ol start="10">
<li><strong>有A、B两人通过信箱进行辩论，每个人都从自己的信箱中取得对方的问题。将答案和向对方提出的新问题组成一个邮件放入对方的邮箱中。假设 A 的信箱最多放 M 个邮件，B 的信箱最多放N个邮件初始时A的信箱中有x个邮件(0&lt;x&lt;M)B的信箱中有y个(0y&lt;N)辩论者每取出一个邮件，邮件数减1。</strong></li>
</ol>
<p>A 和 B 两人的操作过程描述如下:</p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231129000211277.png" alt="image-20231129000211277"></p>
<p>当信箱不为空时，辩论者才能从信箱中取邮件，否则等待。当信箱不满时，辩论者才能将新邮件放入信箱，否则等待。请添加必要的信号量和P、V(或wait、signal)操作，以实现上述过程的同步。要求写出完整过程，并说明信号量的含义和初值。</p>
<pre><code class="c">int empty_a=M-x, full_a=x, mutex_a=1;	
int empty_b=N-y, full_b=y, mutex_b=1;	

coA() &#123;
    P(full_a);
    P(mutex_a);
    从 A 的信箱中取出一个邮件;
    V(mutex_a);
    V(empty_a);
    
    回答问题并提出一个新问题;
    
    P(empty_b);
    P(mutex_b);
    将新邮件放入 B 的邮箱;
    V(mutex_b);
    V(full_b);
&#125;

CoB() &#123;
    P(full_b);
    P(mutex_b);
    从 B 的信箱中取出一个邮件;
    V(mutex_b);
    V(empty_b);
    
    回答问题并提出一个新问题;
    
    P(empty_a);
    P(mutex_a);
    将新邮件放入 A 的邮箱;
    V(mutex_a);
    V(full_a);
&#125;


//*******************************************************
// #define int semaphore

void P(semaphore S) &#123;
    while (S&lt;=0) &#123; /*等待*/ &#125;;
    S--;
&#125;

void V(semaphore S) &#123;
    S++;
&#125;
</code></pre>
<ol start="11">
<li><strong>什么是线程？试述线程与进程的区别。</strong></li>
</ol>
<p>线程是进程内用于调度和占有处理机的基本单位。由<u>线程控制表、存储线程上下文的用户栈以及核心栈</u>组成。线程可分为用户级线程、核心级线程以及用户&#x2F;核心混合型线程等类型。</p>
<p>用户级线程 在用户态下执行，CPU调度算法和各线程优先级都由用户设置，与操作系统内核无关。（内核态不感知）<br>核心级线程 的调度算法及线程优先级的控制权在操作系统内核。<br>混合型线程 的控制权则在用户和操作系统内核二者。</p>
<p><strong>区别：</strong><br>资源：进程是资源管理的基本单位，拥有自己的地址空间和各种资源；线程是处理机调度的基本单位，与其他线程一起共享进程资源，自己没有任何资源。<br>开销：以进程为单位进行处理机切换和调度时，由于涉及<u>资源转移以及现场保护</u>等问题，处理机切换<u>时间较长，资源利用率较低</u>。以线程为单位进行处理机切换和调度时，由于几乎<u>不发生资源变化</u>，特别是地址空间的变化，处理机切换<u>时间较短，资源利用率较高</u>。<br>效率：如果支持多线程，则可以在同一进程中使用多个线程同时执行，减少等待时间，提高系统的响应速度。如果不支持多线程，需要顺序等待执行结束，且期间易发生进行调度，开销较大。<br>状态：线程<u>没有单独的数据和程序空间</u>，因此不能像进程的数据和程序那样，交换到外存存储空间，从而线程<u>没有挂机状态</u>。<br>控制：进程的调度、同步等控制大多由操作系统内核完成，而线程的控制既可以由操作系统内核进行，也可以由用户控制进行。</p>
<ol start="12">
<li><strong>在创建一个进程时所要完成的主要工作是什么？</strong></li>
</ol>
<p>a. OS发现请求创建进程事件后，调用进程创建原语 Create();<br>b. 申请空白 PCB ;<br>c. 为新进程分配资源;<br>d. 初始化进程控制块;<br>e. 将新进程插入就绪队列;</p>
<ol start="13">
<li><strong>在撤销一个进程时所要完成的主要工作是什么？</strong></li>
</ol>
<p>a. 根据被终止进程标识符，从 PCB 中检索出进程 PCB ，读出该进程状态。<br>b. 若终止进程处于执行状态，立即终止该进程的执行，置调度标志真，指示该进程被终止后重新调度。<br>c. 若该进程还有子进程，应将所有子孙进程终止，以防它们成为不可控进程。<br>d. 将被终止进程拥有的全部资源，归还给父进程，或归还给系统。<br>e. 将被终止进程PCB从所在队列或列表中移出，等待其他程序搜集信息。</p>
<p>14. </p>
<ol start="15">
<li><strong>为什么要在 OS 中引入线程？</strong></li>
</ol>
<p>进程 是分配资源的基本单位,而线程则是系统调度的基本单位。减少程序在并发执行时所付出 的时空开销，使 OS 具有更好的并发性，提高 CPU 的利用率。 </p>
<ol start="16">
<li><strong>设有一台计算机，有两个 I&#x2F;O 通道，分别接一台卡片输入机和一 台打印机。卡片机把一叠卡片逐一输入到缓冲区 B1 中，加工处理后 再搬到缓冲区 B2 中，并在打印机上印出</strong>，</li>
</ol>
<p>问：  </p>
<p>a. 系统要设几个进程来完成这个任务？各自的工作是什么？<br>b. 这些进程间有什么样的相互制约关系？<br>c. 用 P、V 操作写出这些进程的同步算法。</p>
<p>c.</p>
<pre><code class="c">vector&lt;item&gt; buffer1, buffer2;
semaphore full_b1=0, full_b2=0, empty_b1=n, empty_b2=m;

void input() &#123;
    while(True) &#123;
        get a item;
        buffer1.push(item);
        V(full_b1);
        P(emtpy_b1);
    &#125;
&#125;

void handle() &#123;
    while (True) &#123;
        P(full_b1);
        buffer1.pop();
        加工信息成item_handled;
        buffer2.push(item_handled);
        V(emtpy_b1);
        V(full_b2);
        P(empty_b2);
    &#125;
&#125;

void output() &#123;
    while(True) &#123;
        P(full_b2);
        buffer2.pop();
        打印输出;
        V(empty_b2);&#125;
&#125;
</code></pre>
<ol start="17">
<li><p>1</p>
</li>
<li><p>1</p>
</li>
<li><p>**原子操作与临界区的区别是什么？ **</p>
</li>
</ol>
<p>原子操作：由处理器保证的不可分割的操作。对于简单的原子操作，处理器会提供单条指令以保证原子性；对于复杂的源自操作，通过添加自旋锁来实现执行过程不被打断。<br>临界区：不允许多个并发进程交叉执行的一段程序。临界区的实现方式，在临界区设置和检查访问标志。进程访问临界区时，通过访问标志判断临界区是否有其他进程在访问。如果有，则等待并循环检查；如果没有，则进入临界区。进程离开临界区时重置访问标志。</p>
<ol start="20">
<li><strong>简述 P、V 原语和加锁法实现进程间互斥的区别</strong>？</li>
</ol>
<ul>
<li>P、V原语<br>采用信号量管理临界区公有资源，信号量仅能由PV原语改变，执行期间不允许中断发生。执行了P原语连接去资源会等待。<ul>
<li>克服了加锁的弊端。</li>
</ul>
</li>
<li>加锁法<br>进程进入临界区就锁上临界区，直到进程退出临界区。进入临界区时检测是否上锁<ul>
<li>CPU浪费，不公平</li>
</ul>
</li>
</ul>
<p>P、V 原语实现：采用<u>信号量</u>管理相应临界区的共有资源，信号量的数值仅能由 P、V 原语操作改变，而 P、V 原语执行期间<u>不允许中断发生</u>。</p>
<ol start="21">
<li>1</li>
<li>1</li>
<li></li>
</ol>
<h2 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h2><ol>
<li>**什么是调度？什么是分级调度？分时系统中有作业调度的概念吗？如果没有，为什么? **</li>
</ol>
<p>处理机调度：指动态地把CPU分配给并发执行的进程。处理机调度实际上就是处理机的分配问题。进程只有取得除处理机以外的各种资源后才能参与处理机的竞争，所以在这以前，要为此作好准备，故要采用的是分级调度。<br>分级调度：就是把一项任务按照一定的步骤分解开来，或者由上到下、由高到低、由简单到复杂（反之亦然），按照一定的计划逐步进行“调兵遣将”执行并最终完成某项工作。<br>分级：作业调度；交换调度；进程调度；线程调度；</p>
<p>分时系统无作业调度。在分时系统中，为缩短响应时间，作业建立在内存，故无提交和后备状态。一旦用户和系统的交互开始，用户要马上进行控制。</p>
<ol start="2">
<li><p>1</p>
</li>
<li><p>1</p>
</li>
<li><p>4</p>
</li>
<li><p>5</p>
</li>
<li><p><strong>何谓死锁?产生死锁的原因和必要条件是什么?</strong></p>
</li>
</ol>
<p>死锁：多个进程因竞争资源造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进。<br>原因：竞争资源，进程推进顺序非法<br>必要条件：互斥条件，请求和保持条件，不剥夺条件和环路等待条件。</p>
<ol start="7">
<li><strong>请详细说明可通过哪些统计预防死锁</strong></li>
</ol>
<p>a. 如果系统有足够的资源，直接一次性分配所有所需资源。<br>b. 已经保持了资源的进程，当其提出新的资源请求而不能立即得到满足时，必须释放它保持的所有资源，待以后需要时再重新申请。<br>c. 将所有资源按类型排序标号，所有进程对资源的请求必须严格按序号递增次序提出。</p>
<p>8. </p>
<ol start="9">
<li><strong>何为作业、作业步和作业流？</strong></li>
</ol>
<p>作业：包含通常的程序和数据，还配有作业说明书。系统根据说明书对程序的运行进行控制。批处理系统中是以作业为基本单位从外存调入内存。<br>作业步：每个作业运行期间都必须经过若干个相对独立互相关联的顺序加工的步骤。<br>作业流：若干个作业在进入系统后依次存放在外村上形成的输入作业流；在操作系统的控制下，逐个作业进程处理，形成了处理作业流。</p>
<p>10. </p>
<ol start="11">
<li><strong>试比较 FCFS 和 SPF 两种进程调度算法。</strong></li>
</ol>
<p>同：都可以用于作业调度和进程调度。（页表那边叫FIFO，差不多意思）<br>异：<br>FCFS：每次都从后备队列中选择一个或多个<u>最先进入</u>该队列的作业，将它们调入内存、分配资源、创建进程、插入到就绪队列。有利于长作业&#x2F;进程，不利于短作业&#x2F;进程。<br>SPF：每次从后备队列中选择一个或多个<u>估计运行时间最短</u>的作业，调入内存运行。该算法有利于短作业&#x2F;进程，不利于长作业&#x2F;进程。</p>
<ol start="12">
<li><strong>几种调度算法（内含计算题）</strong></li>
</ol>
<ul>
<li>先来先服务（FCFS）<br>按作业（进程）到来的先和次序进行调度，即先来的先运行</li>
<li>时间片轮转（RR）<br>把所有就绪进程按照先进先出的原则排成一个队列， 每次选出队首进程给予一个时间片的运行时间，时间片结束产生时钟中断停止该进程运行，并放入末尾，下一个继续运行。</li>
<li>优先级<br>从就绪队列中选出优先级最高的进程到 CPU 上运行<ul>
<li>非抢占式优先级法，抢占式优先级法。</li>
<li>动态优先级、静态优先级</li>
</ul>
</li>
</ul>
<ol start="13">
<li>13</li>
</ol>
<h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><ol>
<li><p>1</p>
</li>
<li><p>2</p>
</li>
<li><p>3</p>
</li>
<li><p>4</p>
</li>
<li><p>5</p>
</li>
<li><p>6</p>
</li>
<li><p><strong>什么是段式管理?其与页式管理的有何区别（请至少举例说明三点）? （段式管理即分段存储管理，页式管理即分页存储管理）</strong></p>
</li>
</ol>
<p>段式管理：将程序按照内容或过程（函数）关系分成段，每段拥有自己的名字。一个用户作业或进程所包含的段对应于一个二维线性虚拟空间，也就是一个二维虚拟存储器。段式管理程序以段为单位分配内存，然后通过地址映射机构把段式虚拟地址转换成实际的内存物理地址。<br>同页式管理类似，段式管理也采用只把经常访问的段驻留内存，而把那些在将来一段时间内不被访问的段放入外村，待需要时自动调入相关段的方法实现二维虚拟存储器。</p>
<p><strong>区别：</strong></p>
<p>a. 编译<br>页式管理：源程序进行编译连接时是将主程序、子程序、数据区等按照线性空间的一维地址顺序排列起来。<br>段式管理：将程序按照内容或过程（函数）关系分成段，每段拥有自己的名字。一个用户作业或进程所包含的段对应于一个二维线性虚拟空间，也就是一个二维虚拟存储器。</p>
<p>b. 虚拟存储<br>段式管理：每次交换的是一次有意义的信息<br>页式管理：只交换固定大小的页，需要多次的缺页中断，才能把所需信息完整地调入内存</p>
<p>c.<br>段式管理：可根据需要动态增长</p>
<p>d.<br>段式管理：对于具有完整逻辑功能的信息段进行共享</p>
<p>e.<br>段式管理：便于进行动态链接<br>页式管理：动态链接过程非常复杂</p>
<ol start="8">
<li><strong>试全面比较连续分配和离散分配存储器管理方式</strong></li>
</ol>
<p><strong>连续分配：</strong><br>为一个用户程序分配一个连续的地址空间，包括单一连续分配方式和分区式分配方式。</p>
<ul>
<li>单一分配方式：<br>将内存分为系统区和用户区，系统区供操作系统使用，用户区供用户使用，是最简单的一种存储方式，但只能用于单用户单任务的操作系统中</li>
<li>分区式分配方式：<br>分区式分配方式分为固定分区和动态分区<ul>
<li>固定分区：<br>最简单的多道程序的存储管理方式，由于每个分区的<u>大小固定</u>，必然会造成存储空间的<u>浪费</u></li>
<li>动态分区：<br>根据进程<u>实际需要</u>，<u>动态地</u>为之分配<u>连续</u>的内存空间。有三种分配算法，首次适应算法，循环首次适应算法，最佳适应算法。</li>
</ul>
</li>
</ul>
<p><strong>离散分配：</strong></p>
<p>基于将一个进程直接分散地分配到许多不相邻的分区中的思想，分为 分页式存储管理，分段式存储管理，段页式存储管理。</p>
<ul>
<li><strong>分页式存储管理</strong><br>旨在提高内存利用率，满足系统管理的需要。</li>
<li><strong>分段式内存管理</strong><br>旨在满足用户（程序员）的需要，在实现共享和保护方面优于分页式存储管理。</li>
<li><strong>段页式存储管理</strong><br>结合两者，取长补短，即具有分段系统便于实现，可共享，易于保护，可动态链接等有点，又能像分页系统那样很好的解决外部碎片的问题，以及各个分段可离散分配内存等问题，显然是一种比较有效的存储管理方式。</li>
</ul>
<ol start="9">
<li><strong>实现地址重定位的方法有几类？试列举其各自的特点</strong></li>
</ol>
<p>两种：静态地址重定位和动态地址重定位</p>
<ul>
<li>静态地址重定位：<br>程序执行<u>之前</u>，由装配程序完成地址映射工作。<ul>
<li>优点：不需要硬件支持。</li>
<li>缺点：无法实现虚拟存储器，必须占用连续的内存空间和难以做到程序和数据的共享。</li>
</ul>
</li>
<li>动态地址重定位：<br>程序执行<u>过程中</u>，在 CPU 访问内存之前由硬件地址变换机构将要访问的程序或数据地址转换为内存地址。<ul>
<li>优点：提供了实现虚拟存储器的基础，可以对内存进行非连续分配，有利于程序段的共享</li>
</ul>
</li>
</ul>
<p>10. </p>
<p>11. </p>
<ol start="12">
<li><strong>何为静态链接？何谓装入时动态链接和运行时的动态链接？</strong></li>
</ol>
<ul>
<li><strong>静态链接</strong><br><u>程序运行前</u>，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开的方式。</li>
<li><strong>动态链接</strong><ul>
<li><strong>装入时动态链接</strong><br>将用户源编译后得到的一组目标模块，在转入内存时采用边装入边链接的链接方式。</li>
<li><strong>运行时动态链接</strong><br>对某些目标模块的链接，是在<u>程序执行中需要该目标模块</u>时，才对它进行的链接。</li>
</ul>
</li>
</ul>
<ol start="13">
<li><strong>分区存储管理中常用哪些分配策略？比较它们的优缺点。</strong></li>
</ol>
<ul>
<li><strong>首次适应算法</strong><ul>
<li>优点：保留了高址部分的大空闲区，利于后来的<u>大作业分配</u></li>
<li>缺点：留下许多<u>难以利用的小空闲区</u>，每次查找都从低址开始<u>增加了系统开销</u>。</li>
</ul>
</li>
<li><strong>循环首次适应算法</strong><ul>
<li>优点：内存空间<u>分布均匀</u>，<u>减少</u>了系统查找<u>开销</u></li>
<li>缺点：缺乏<u>大空闲分区</u>，导致<u>不能装入大型作业</u></li>
</ul>
</li>
<li><strong>最佳适应算法</strong><ul>
<li>优点：每次分配给文件的都是最<u>适合该文件大小的分区</u></li>
<li>缺点：留下许多<u>难以利用的小空闲区</u></li>
</ul>
</li>
<li><strong>最坏适应算法</strong><ul>
<li>优点：剩下空闲区都不太小，产生<u>碎片几率小</u>，对<u>中小型文件</u>分配分区操作有利</li>
<li>缺点：存储器中<u>缺乏大空闲区</u>，对大型文件分区不利</li>
</ul>
</li>
</ul>
<ol start="14">
<li><strong>分段和分页存储管理有何区别？</strong></li>
</ol>
<p>a.<br>页是信息的物理单位，分页时为了实现<u>离散分配方式</u>，以消减内存的外部零头，<u>提高内存利用率</u>。<br>段是信息的逻辑单位，它含有一组<u>相对完整的信息</u>。</p>
<p>b.<br>页的<u>大小固定</u>且由<u>系统决定</u>，由系统把逻辑地址划分为<u>页号和页内地址</u>两部分，是由机械硬件实现的，因而在系统中<u>只能有一种大小的页面</u>。<br>段的<u>长度不固定</u>，<u>决定于用户</u>所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p>
<p>c.<br>分页的作业地址空间是<u>一维</u>，<br>分段的作业地址空间是<u>二维</u>。</p>
<ol start="15">
<li><p>15</p>
</li>
<li><p>16</p>
</li>
<li><p>17</p>
</li>
<li><p>存储器有关概念</p>
</li>
</ol>
<ul>
<li><strong>逻辑地址</strong><br>用户程序经编译之后的每个目标模块都以0为基地址顺序编址</li>
<li><strong>物理地址</strong><br>内存中各物理单元的地址是从统一的基地址顺序编址。</li>
<li><strong>重定位</strong><br>把逻辑地址转变为内存的物理地址的过程。</li>
<li><strong>静态重定位</strong><br>在目标程序装入内存时，由装入程序对目标程序中的指针和数据的地址进行修改，即把程序的逻辑地址都改成实际的内存地址。重定位在程序装入时一次完成</li>
<li><strong>动态重定位</strong><br>在程序执行期间，每次访问内存之间进行重定位，这种变换是靠硬件地址变换机构实现的。</li>
</ul>
<ol start="19">
<li><strong>虚拟内存中的置换算法</strong></li>
</ol>
<ul>
<li><strong>先进先出（FIFO）</strong>（FCFS貌似是进程作业那边的说法，差别不大）<br>换出<u>最先进入</u>内存的页。</li>
<li><strong>最佳置换（OPT）</strong><br>换出<u>将来不再被使用</u>或<u>最远的将来</u>才被访问的页。</li>
<li><strong>最近最少使用算法（LRU）</strong><br>换出<u>最近一段时间最久没有使用过</u>的页。</li>
<li><strong>最近未使用置换法（NUR）</strong>LRU 的近似方法，易实现，开销小<br>在存储分块表的<u>每一表项中增加一个引用位</u>，操作系统定期将他们置为0。当某一页被<u>访问时</u>，由硬件将该位<u>置为1</u>。需要淘汰一页时，把<u>该位为0的页淘汰</u>出去。</li>
</ul>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><ol>
<li><strong>数据传送控制方式有哪几种？试比较它们各自的优缺点。</strong></li>
</ol>
<ul>
<li><strong>程序直接控制方式</strong><br>用户进程<u>直接控制</u>内存或CPU和外围设备之间的数据传送。<ul>
<li>优点：控制<u>简单，</u>不需要多少硬件支持</li>
<li>缺点：CPU<u>浪费大量时间等待</u>设备输入输出，CPU和外围设备只能<u>串行</u>工作。</li>
</ul>
</li>
<li><strong>中断控制方式</strong><br>利用向 CPU 发送<u>中断</u>的方式控制外围设备和 CPU 之间的数据传送<ul>
<li>优点：大大<u>提高</u>了 CPU 的<u>利用率</u>，且支持多道程序和设备的<u>并行</u>操作。</li>
<li>缺点：<ul>
<li>由于数据缓冲<u>寄存器比较小</u>，如果中断次数较多，仍然占用了大量 CPU 时间；</li>
<li>外围<u>设备较多</u>时，由于中断次数的急剧增加，可能造成 CPU 无法响应中断而出现<u>中断丢失</u>的现象；</li>
<li>如果<u>外围设备比较快</u>，可能会出现 CPU 来不及从数据缓冲寄存器中取走数据而<u>丢失数据</u>的情况；</li>
<li>每次传输的数据量以字节为单位，<u>效率较低</u>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>DMA 方式</strong><br>在<u>外围设备和内存之间</u>开辟直接的<u>数据交换通路</u>进行数据传送。<ul>
<li>优点：<ul>
<li>除了数据在数据块传送开始时需要 CPU 的启动指令，在整个数据块传送结束时需要发中断通知 CPU 进行中断处理之外，不需要 CPU 的频繁干涉。</li>
<li>以数据块为单位，效率较高。</li>
</ul>
</li>
<li>缺点：<ul>
<li>外围设备越来越多的情况下，多个DMA控制器同时使用，会引起内存地址的冲突使得控制过程进一步复杂化。</li>
</ul>
</li>
</ul>
</li>
<li><strong>通道方式</strong><br>使用<u>通道</u>来控制<u>内存或 CPU 和外围设备之间</u>的数据传送。通道是一个独立于 CPU 的专门负责输入输出控制的机构，它控制设备于内存直接进行数据交换。<ul>
<li>优点：<ul>
<li>进一步<u>减轻</u>了 CPU 的<u>工作负担</u>，增加了计算机系统的<u>并行</u>工作程度；</li>
<li>每次可以传输<u>一组</u>数据块，<u>效率最高</u>；</li>
</ul>
</li>
<li>缺点：增加了<u>额外的硬件</u>，造假昂贵。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>试列举常用的硬盘调度算法，并说明其主要特点</strong></li>
</ol>
<ul>
<li><p><strong>先来先服务（FCFS）</strong><br>根据进程请求访问硬盘的<u>先后顺序</u>进行调度。</p>
<ul>
<li><u>公平性</u>，有望达到<u>较好的性能</u>。</li>
<li>如果由大量进程竞争使用硬盘，性能上接近随机调度</li>
</ul>
</li>
<li><p><strong>最短寻找时间优先（SSTF）</strong><br>选择调度处理的磁道是与<u>当前磁头所在磁道距离最近</u>的磁道，以使每次的<u>寻找时间最短</u>。</p>
<ul>
<li>能提供比FCFS更好的性能，但是可能产生 “饥饿” 现象。</li>
</ul>
</li>
<li><p><strong>扫描（SCAN，又称电梯算法）</strong><br>在磁头<u>当前移动方向</u>上选择与<u>当前磁头所在磁道距离最近</u>的磁道。实际上就是SSTF的基础上规定移动方向为当前移动方向。</p>
<ul>
<li>对最近扫描过的区域不公平，局部性方面不如 FCFS 和 SSTF 。</li>
<li>总是严格地从盘面的一端到另一端</li>
</ul>
</li>
<li><p><strong>循环扫描（C-SCAN）</strong></p>
<p>在扫描算法的基础上规定磁头单项移动来提供服务，回返时<u>直接快速移动至起始端</u>而<u>不服务任何请求</u>。</p>
<ul>
<li>总是严格地从盘面的一端到另一端</li>
</ul>
</li>
<li><p><strong>LOOK 和 C-LOOK</strong><br>改进的 SCAN 和 C-SCAN，只是磁头移动只需要到达<u>最远端的一个请求即可返回，不需要到达磁盘端点</u>。</p>
</li>
</ul>
<ol start="3">
<li><p>3</p>
</li>
<li><p><strong>为什么要引入设备独立性？试说明如何实现设备独立性</strong><br>提高系统的可适应性和可扩展性，实现设备独立性。应用程序独立于具体使用的物理设备，即应用程序以逻辑设备名称来使用某类设备。</p>
</li>
</ol>
<ul>
<li><p>优点：</p>
<ul>
<li>设备分配时的灵活性</li>
<li>易于实现 I&#x2F;O 重定向</li>
</ul>
</li>
<li><p>实现：<br>逻辑设备，物理设备。在应用程序中，使用逻辑设备名称来请求使用某类设别；系统执行时是使用物理设备名称。</p>
<ul>
<li>鉴于驱动程序是一个与硬件（或设备）紧密相关的软件，必须在驱动程序之上设置一层软件，称为设备独立性软件，以执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换并向用户层软件提供统一接口，从而实现设备独立性。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>在设备分配中，什么是安全分配方式和不安全分配方式？请说明其特点</strong></li>
</ol>
<ul>
<li><strong>安全分配方式</strong><br>每当进程发出 I&#x2F;O 请求后，便进入阻塞状态，直到其 I&#x2F;O 操作完成时才被唤醒。<ul>
<li>一旦进程已经获得某种设备（资源）后便阻塞，不可能再请求任何资源，运行时又不保持任何资源。摒弃了死锁四个表要条件之一的 “请求和保持” ，所以分配是安全的</li>
<li>进程进展缓慢，CPU 与 I&#x2F;O 设备是串行工作的。</li>
</ul>
</li>
<li><strong>不安全分配方式</strong><br>进程发出 I&#x2F;O 请求后仍继续执行，需要时又可发出第二个、第三个 I&#x2F;O 请求。仅当进程所请求的设备已被另一个进程占有时，进程才进入阻塞状态<ul>
<li>一个进程可以操作多个设备，进程推进迅速。</li>
<li>分配不安全，可能具有 ”请求和保持“ 条件，会造成死锁。</li>
<li>需要添加一个功能——对本次设备分配是否会发生死锁进行安全性检查。</li>
</ul>
</li>
</ul>
<ol start="6">
<li><strong>DMA 方式与中断控制方式的主要区别是什么？</strong></li>
</ol>
<ul>
<li><p><strong>中断时间</strong></p>
<ul>
<li>中断控制：每个数据传送完成后中断CPU</li>
<li>DMA：所要求传送的一批数据全部传送结束时中断CPU</li>
</ul>
</li>
<li><p><strong>控制</strong></p>
<ul>
<li>中断控制：中断处理时CPU控制</li>
<li>DMA：DMA控制器控制。但数据传送的方向、存放数据的内存始址及传送数据的长度仍由 CPU 控制。</li>
</ul>
</li>
<li><p><strong>核心</strong></p>
<ul>
<li>中断控制：以CPU为核心。</li>
<li>DMA：以存储器为核心，能与 CPU 并行工作</li>
</ul>
</li>
<li><p><strong>传输量</strong></p>
<ul>
<li>中断控制：以字节为单位</li>
<li>DMA：批量传输数据</li>
</ul>
</li>
</ul>
<ol start="7">
<li><strong>试说明 DMA 的工作流程</strong></li>
</ol>
<p>当 CPU 要从磁盘读入数据块时，先向磁盘控制器发送一条读命令。该命令被送到命令寄存器CR中。同时还发送本次要读入数据的内存起始目标地址，送入内存地址寄存器 MAR；本次要读数据的字节数送入数据计数器 DC，将磁盘中的源地址直接送到 DMA 控制器 I&#x2F;O 控制逻辑上。然后启动 DMA 控制器传送数据， 以便 CPU 处理其他任务。整个数据传送过程由 DMA 控制器控制。</p>
<p><img src="https://starain-1252568110.cos.ap-beijing.myqcloud.com/blog/image-20231128220754568.png" alt="image-20231128220754568"></p>
<ol start="8">
<li><p><strong>试说明设备驱动程序应具有哪些功能？</strong></p>
<ul>
<li>（转换）将接收到的<u>抽象</u>要求<u>转为</u>具体要求</li>
<li>（校验）<u>检查</u>用户 I&#x2F;O 请求合法性，了解 I&#x2F;O 设备状态，传递有关参数，设置设备工作方式；</li>
<li>（执行）<u>发出</u> I&#x2F;O 命令，<u>启动</u>分配到的 I&#x2F;O 设备，完成指定 I&#x2F;O 操作；</li>
<li>（响应）及时<u>响应</u>由控制器或通道发来的中断请求，根据中断类型<u>调用相应中断处理程序处理</u>；</li>
<li>（其他）对于<u>有通道</u>的计算机，驱动程序还应该根据用户 I&#x2F;O 请求<u>自动构成通道程序</u>。</li>
</ul>
</li>
<li><p><strong>设备中断处理程序通常需完成哪些工作？</strong></p>
<ul>
<li>唤醒被阻塞的驱动程序进程；（阻塞）</li>
<li>保护被中断进程的 CPU 环境；（保护现场，即保存上下文）</li>
<li>分析中断原因、转入相应的设备中断处理程序；（判断中断、陷入还是异常）</li>
<li>进行中断处理；</li>
<li>恢复被中断进程；（恢复现场，即恢复上下文）</li>
</ul>
</li>
<li><p><strong>目前常用的磁盘调度算法有哪几种？每种算法优先考虑的问题是什么？</strong><br>常用的有：FCFS、SSTF 以及 SCAN 等</p>
<ul>
<li>FCFS：进程访问磁盘的<u>先后次序</u></li>
<li>SSTF：要求访问的磁道与当前磁头所在磁道距离<u>是否最近</u></li>
<li>SCAN：要求访问的磁道与当前磁头 所在磁道距离<u>是否最近</u>，但更优先考虑磁头<u>当前移动方向</u></li>
</ul>
</li>
<li><p><strong>SPOOLing 系统由哪几部分组成？以打印机为例说明如何利用 SPOOLing 计数实现多个进程对打印机的共享？</strong></p>
</li>
</ol>
<p>组成：磁盘上的输入井和输出井，内存中的输入缓冲区和输出缓冲区，输入进程和输出进程。</p>
<p>实现：<br>接受用户进程的请求时，由输出进程在输出井为它申请空闲缓冲区，将要打印的数据卷入其中，再为用户进程申请一张空白的用户打印请求表，将打印请求填入表中后将该表挂到打印机队列上。<br>用户进程认为打印进程已经完成，不用等待打印完成。打印机空闲时，从输出进程从请求队列队首取出一张打印表，根据表中的要求将打印数据从输出井传到内存缓冲区，由打印机进行输出打印。虽然系统中只有一个打印机，但是每个进程提出打印请求时，系统都会同意他的请求，并在输出井为其分配一个存储区，相当于分配了一个逻辑设备，使每个用户进程都能感觉到自己在独占一台打印机，从而实现了打印机的共享。</p>
<ol start="12">
<li>12</li>
</ol>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a><strong>文件管理</strong></h2><ol>
<li><strong>有结构文件按记录的组织形式可分为哪些种类？试描述其主要特点。</strong></li>
</ol>
<ul>
<li><p><strong>顺序文件</strong><br>文件中的<u>记录按顺序排列</u>，通常<u>定长</u>，可以顺序存储或以链表形式存储。</p>
<ul>
<li><strong>串结构</strong><br>记录之间的顺序通常由<u>时间</u>决定</li>
<li><strong>顺序结构</strong><br>记录之间的顺序按<u>关键字</u>顺序排列</li>
</ul>
</li>
<li><p><strong>索引文件</strong><br>为变长记录建立一张<u>索引表</u>，为记录设立表项，加快索引速度。</p>
</li>
<li><p><strong>索引顺序文件</strong><br>为顺序文件建立一张<u>索引表</u>，将顺序文件<u>分组</u>，索引表为<u>每组第一个记录</u>。</p>
</li>
<li><p><strong>直接文件或散列文件</strong><br><u>给定</u>记录的键值或<u>通过Hash函数</u>转换的键值<u>直接决定记录的物理地址</u>，无顺序特性。</p>
</li>
</ul>
<ol start="2">
<li><strong>为文件分配磁盘块时，有哪些磁盘空间分配方式？试描述其主要特点</strong></li>
</ol>
<ul>
<li><strong>连续分配</strong><br>文件在磁盘上占有一组<u>连续</u>的块。<ul>
<li>访问磁盘时的寻道数和寻道时间最小，实现<u>简单</u>，存取速度<u>快</u>，</li>
<li>文件长度<u>不宜动态增加</u>，空间<u>利用率低</u></li>
</ul>
</li>
<li><strong>连接分配</strong><br><u>离散</u>分配的方式<ul>
<li><u>磁盘利用率高</u>，可以<u>动态分配</u>，<u>增删改方便</u></li>
<li><u>不适合随机访问</u>，降低了<u>存储效率</u>，<u>可靠性也较差</u></li>
<li>有显式分配（链接物理块的指针单独<u>成表</u>）和隐式分配（文件除最后一个磁盘块外都有<u>指向下一个块</u>的指针）</li>
</ul>
</li>
<li><strong>索引分配</strong><br>把每个文件所有盘块号都集中放在一起构成<u>索引块（表）</u><ul>
<li>支持顺序访问也<u>支持随机访问</u>，效率<u>高</u>，<u>便于删除</u></li>
<li>表<u>占用一定空间</u></li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>什么是文件、文件系统？文件系统有哪些功能？</strong></li>
</ol>
<ul>
<li><strong>文件</strong><br>一组赋名的相关字符流的集合，或相关记录的集合。</li>
<li><strong>文件系统</strong><br>操作系统与管理文件相关的软件和数据</li>
<li><strong>功能</strong><ul>
<li>建立、撤销、修改、复制（增删改查）文件，完成对文件的按名存取和进行存取控制。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>什么是文件目录？文件目录中包含哪些信息？</strong></li>
</ol>
<ul>
<li><strong>文件目录</strong><br>一个文件的文件名和对该文件控制管理的说明信息。</li>
<li><strong>包含信息</strong><br>文件名，其对应的文件内部标识，文件信息在设备上的第一个物理块地址。可能还有文件逻辑结构，物理结构，存取控制和管理等信息。</li>
</ul>
<ol start="5">
<li><strong>文件存储空间管理中，对于空闲块的管理有三种常用方法，请说明其对空闲块是如何进行组织的？</strong></li>
</ol>
<ul>
<li><strong>空闲表法</strong><br>连续分配，为外存所有空闲区建立表，存有表项序号，空闲区第一个盘块号，空闲盘块数等信息。所有空闲区递增排列。</li>
<li><strong>空闲链表法</strong><br>空闲盘区拉成一条空闲链<ul>
<li><strong>空闲盘块链</strong><br>以盘块为单位拉成一条链，创建文件时，从链首开始拉取合适盘块给用户。删除文件时，回收盘口插入空闲盘块链尾。</li>
<li><strong>空闲盘区链</strong><br>以空闲盘区为单位拉成一条链，盘区中有指向下一盘区的指针，盘区大小等信息。回收时与空闲盘区合并。</li>
</ul>
</li>
<li><strong>位示图法</strong><br>利用二进制的一位表示一个盘块使用情况。“0” 表示空闲，“1”表示已分配。</li>
</ul>
<ol start="6">
<li><strong>何谓数据项、记录和文件？</strong></li>
</ol>
<ul>
<li><strong>数据项</strong><ul>
<li>基本数据项<br>一个对象属性的字符集，具有数据名、数据类型、数据值三个特性。</li>
<li>组合数据项<br>若干数据项构成</li>
</ul>
</li>
<li><strong>记录</strong><br>一组相关数据项的集合，用于描述对象某方面的属性。</li>
<li><strong>文件</strong><br>一组赋名的相关字符流的集合，或相关记录的集合。</li>
</ul>
<ol start="7">
<li><strong>何谓逻辑文件？何谓物理文件？</strong></li>
</ol>
<ul>
<li><strong>逻辑文件</strong><br>存储的数据的一种视图方式，不包含具体数据，仅包含物理文件中数据的索引。</li>
<li><strong>物理文件</strong><br>文件在外存上的存储组织形式</li>
</ul>
<ol start="8">
<li><p>同7</p>
</li>
<li><p><strong>何谓事务？如何保证事务的原子性？</strong></p>
</li>
</ol>
<ul>
<li><strong>事务</strong><br>访问和修改各种数据项的一个程序单位</li>
<li><strong>保证原子性</strong><br>保证一个事务对一批数据执行<u>修改</u>操作时，<u>要么全部完成，要么全部不执行</u>。</li>
</ul>
<h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a><strong>操作系统接口</strong></h2><ol>
<li><strong>操作系统包括哪几种类型的用户接口？它们分别适用于哪种情况？</strong></li>
</ol>
<ul>
<li>命令接口<br>支持用户通过中断使用计算机系统</li>
<li>图形化接口<br>同命令接口</li>
<li>程序接口<br>用户编制程序时使用</li>
<li>网络用户接口<br>面向网络应用的接口</li>
</ul>
<ol start="2">
<li><strong>比较一般的过程调用和系统调用？</strong></li>
</ol>
<ul>
<li><strong>运行状态</strong><ul>
<li>一般调用的<u>调用过程和被调用过程</u>均为<u>同一个态</u>（用户态或系统态）</li>
<li>系统调用的<u>调用过程</u>是用户态下的<u>用户程序</u>，<u>被调用过程</u>是系统态下的<u>系统程序</u></li>
</ul>
</li>
<li><strong>软中断进入机制</strong><ul>
<li>一般调用可<u>直接</u>由调用过程转向被调用过程</li>
<li>系统调用<u>不允许</u>，一般通过<u>软中断机制</u>，进入内核，经分析后才能转向命令处理程序</li>
</ul>
</li>
<li><strong>返回及重新调度</strong><ul>
<li>一般调用结束后，返回调用点<u>继续执行</u>。</li>
<li>系统调用结束后，需要对所有进程重新调度，若进程仍有<u>最高优先权</u>才能继续调用。</li>
</ul>
</li>
<li><strong>嵌套调用</strong><ul>
<li>系统调用存在系统嵌套而非用户过程的情况</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>什么是系统调用？它都有哪些类型？</strong><br>内核中设置的用于实现各种系统功能的子程序或过程，提供给用户程序调用。</li>
</ol>
<ul>
<li><strong>进程控制类</strong><br>进程的创建、终止、等待、替换、进程数据段大小改变及进程标识符或指定进程属性获得等；</li>
<li><strong>文件操纵类</strong><br>文件的创建、打开、关闭、读&#x2F;写，及文件读写指针移动，属性修改，目录创建及索引结点建立等；</li>
<li><strong>进程通信类</strong><br>实现进程间通信机制，如消息传递、共享存储区、信息量机制等；</li>
<li><strong>信息维护类</strong><br>日期、时间及系统相关信息设置和获得；</li>
</ul>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2023 - 2024 ⭐星雨起源⭐
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;海画沙夢w
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>



        <script src="/js/main.js">  </script>
        <script>
            console.info("Welcome to Argvchs' blog!");
            if (!window.hasOwnProperty("ontouchstart")) {
                let html = '<canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas><script src="https://static-argvchs.netlify.app/js/fireworks.min.js"><\/script>';
                document.body.append(document.createRange().createContextualFragment(html));
            }
        </script>


        <!-- 鼠标点击特效 -->
        <canvas
            id="fireworks"
            style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
        ></canvas>
        <script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
        <script src="/js/fireworks.min.js"></script>



        <!-- 鼠标指针特效 -->
        <div id="cursor"></div>
        <link rel="stylesheet" href="/css/cursor.min.css" />
        <script src="/js/cursor.min.js"></script>



        <!-- 流星背景特效 -->
        <canvas
            id="background"
            style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
        ></canvas>
        <script src="/js/background.min.js"></script>




       



        
        
<script
    src="https://giscus.app/client.js"
    data-repo="StaRainorigin/StaRainorigin.github.io"
    data-repo-id="R_kgDOH6wiAg"
    data-category="General"
    data-category-id="DIC_kwDOH6wiAs4CY_KG"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="https://static-argvchs.netlify.app/css/giscus.css"
    data-lang="zh-CN"
    crossorigin
    async
></script>





        
    </body>
</html>
